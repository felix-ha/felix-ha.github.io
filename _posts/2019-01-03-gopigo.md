---
mathjax: true
---


# Self Driving GoPiGo


First of all to get your attention right away:
[here is the video of the car driving.](https://youtu.be/DT_9L6zDL5M)
Now you want to know how it works, don't you? Don't worry I am going to explain now. 

The heart of the algorithm is a convolutional neural network that is trained to deceide wheter a piece of the floor is save for driving or border.
For that I collected images and created a dataset. After this a trained the network with tensorflow. 
The architecture of the net is based on the network for the MNIST dataset form the book “Fundamentals of Deep Learning: Designing Next-Generation Machine Intelligence Algorithms” from Nikhil Buduma. 
It is a quit basic network with two layers of convolution and max pooling and two fully connected layers.
Nonetheless it gives enough performance to provide a quit stable autopilot for the car. 

The algorithm is divided in two parts: 

1. The image is classified and a so called autopilotmatrix $$A$$ is generated.

2. With a given $$A$$ a driving instruction for the car is determined. 


You can look at the autopilot as a mapping from the set of autopilotmatrices $$\mathcall{A}$$ to the set of possibles moves $$\mathcall{M}$$ of the car. 
$$\mathcall{M} := \{f(v), b\}$$

The part of the algorithm that decides in which way the car should drive works the following way. Let $$T$$ be a $$ 4 \times 3$$ Matrix and a $$v$$ be a $$4 \times 1$$ vector. The names indicate the meaning, $$T$$ stand for turn and $$v$$ stands for velocity. 
So the autopilotmatrix is  $$A = \begin{pmatrix}
 & v_1 &  \\
 & v_2 &  \\
 & v_3 &  \\ 
  & v_4 &  \\
 a_{11} &  a_{11} & a_{11}  \\
 a_{11} &  a_{11} & a_{11}  \\ 
 a_{11} &  a_{11} & a_{11}  \\
 a_{11} &  a_{11} & a_{11} 
 \end{pmatrix}$$

```python
def driving_algorithm():
    if (steps_to_go == 4):
        distance_to_move = 700
    else:
        distance_to_move = 350

    farest_line = self.car.prediction_array[0, :]

    if (np.sum(self.car.prediction_array) <= 2):
        self.app.autopilot_successfully = True

        self.app.drive_backward(1000)
        time.sleep(1.5)

        random_distance = random.random() * 750 + 500

        if (random.random() > 0.5):
            self.app.drive_right(random_distance)
        else:
            self.app.drive_left(random_distance)
```




Here is the UI:
![UI](/images/1.png)



Here is a image where the car should stop.
![all_black](/images/2.png)

Here is another image. 
![half_black](/images/3.png)
